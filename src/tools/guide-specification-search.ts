import {
  UserQuery,
  GuidanceResponse
} from '../types/guidance';
import { GuidanceEngine } from '../utils/guidance-engine';
import { TemplateGenerator } from '../utils/template-generator';

export class GuideSpecificationSearchTool {
  private guidanceEngine: GuidanceEngine;

  constructor(guidanceEngine: GuidanceEngine) {
    this.guidanceEngine = guidanceEngine;
  }

  getDefinition() {
    return {
      name: 'guide_specification_search',
      description: 'Helps users formulate effective specification searches and provides targeted guidance for finding relevant 3GPP specifications',
      inputSchema: {
        type: 'object',
        properties: {
          query: {
            type: 'string',
            description: 'The search query or topic of interest'
          },
          userLevel: {
            type: 'string',
            enum: ['beginner', 'intermediate', 'expert'],
            description: 'User expertise level for tailored guidance'
          },
          domain: {
            type: 'string',
            description: 'Specific domain or area of focus (optional)'
          }
        },
        required: ['query']
      }
    };
  }

  async execute(args: any) {
    const query: UserQuery = {
      text: args.query,
      userLevel: args.userLevel || 'intermediate',
      domain: args.domain
    };

    const analysis = await this.guidanceEngine.analyzeQuery(query);
    const guidance = await this.guidanceEngine.generateGuidance(query, analysis);

    return {
      content: [
        {
          type: 'text',
          text: this.formatGuidanceResponse(guidance)
        }
      ]
    };
  }

  private formatGuidanceResponse(guidance: GuidanceResponse): string {
    let formatted = `# ${guidance.summary}\n\n`;

    guidance.sections.forEach(section => {
      formatted += `## ${section.title}\n\n`;
      formatted += `${section.content}\n\n`;
    });

    if (guidance.nextSteps && guidance.nextSteps.length > 0) {
      formatted += `## Next Steps\n\n`;
      guidance.nextSteps.forEach(step => {
        formatted += `- ${step}\n`;
      });
      formatted += '\n';
    }

    if (guidance.relatedTopics && guidance.relatedTopics.length > 0) {
      formatted += `## Related Topics\n\n`;
      guidance.relatedTopics.forEach(topic => {
        formatted += `- ${topic}\n`;
      });
      formatted += '\n';
    }

    formatted += `---\n*Confidence: ${Math.round(guidance.confidence * 100)}%*\n`;
    formatted += `*Generated by 3GPP MCP Server v2 - Intelligent Guidance*`;

    return formatted;
  }
}