import {
  UserQuery,
  GuidanceResponse
} from '../types/guidance';
import { GuidanceEngine } from '../utils/guidance-engine';

export class MapRequirementsToSpecsTool {
  private guidanceEngine: GuidanceEngine;

  constructor(guidanceEngine: GuidanceEngine) {
    this.guidanceEngine = guidanceEngine;
  }

  getDefinition() {
    return {
      name: 'map_requirements_to_specs',
      description: 'Maps technical requirements to appropriate 3GPP specifications with reading order and implementation guidance',
      inputSchema: {
        type: 'object',
        properties: {
          requirements: {
            type: 'string',
            description: 'Technical requirements or use case description'
          },
          implementationFocus: {
            type: 'boolean',
            description: 'Whether to focus on implementation aspects'
          }
        },
        required: ['requirements']
      }
    };
  }

  async execute(args: any) {
    const requirements = args.requirements;
    const implementationFocus = args.implementationFocus || false;

    const query: UserQuery = {
      text: requirements,
      userLevel: implementationFocus ? 'expert' : 'intermediate'
    };

    const analysis = await this.guidanceEngine.analyzeQuery(query);
    analysis.intent = 'implementation';

    const guidance = await this.guidanceEngine.generateGuidance(query, analysis);

    return {
      content: [
        {
          type: 'text',
          text: this.formatGuidanceResponse(guidance)
        }
      ]
    };
  }

  private formatGuidanceResponse(guidance: GuidanceResponse): string {
    let formatted = `# ${guidance.summary}\n\n`;

    guidance.sections.forEach(section => {
      formatted += `## ${section.title}\n\n`;
      formatted += `${section.content}\n\n`;
    });

    if (guidance.nextSteps && guidance.nextSteps.length > 0) {
      formatted += `## Next Steps\n\n`;
      guidance.nextSteps.forEach(step => {
        formatted += `- ${step}\n`;
      });
      formatted += '\n';
    }

    if (guidance.relatedTopics && guidance.relatedTopics.length > 0) {
      formatted += `## Related Topics\n\n`;
      guidance.relatedTopics.forEach(topic => {
        formatted += `- ${topic}\n`;
      });
      formatted += '\n';
    }

    formatted += `---\n*Confidence: ${Math.round(guidance.confidence * 100)}%*\n`;
    formatted += `*Generated by 3GPP MCP Server v2 - Intelligent Guidance*`;

    return formatted;
  }
}