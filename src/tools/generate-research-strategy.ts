import {
  UserQuery,
  GuidanceResponse
} from '../types/guidance';
import { GuidanceEngine } from '../utils/guidance-engine';

export class GenerateResearchStrategyTool {
  private guidanceEngine: GuidanceEngine;

  constructor(guidanceEngine: GuidanceEngine) {
    this.guidanceEngine = guidanceEngine;
  }

  getDefinition() {
    return {
      name: 'generate_research_strategy',
      description: 'Creates comprehensive research approaches for complex 3GPP topics with phased methodology',
      inputSchema: {
        type: 'object',
        properties: {
          topic: {
            type: 'string',
            description: 'Research topic or area of investigation'
          },
          complexity: {
            type: 'string',
            enum: ['basic', 'intermediate', 'advanced'],
            description: 'Complexity level of the research'
          },
          timeframe: {
            type: 'string',
            description: 'Available timeframe for research (optional)'
          }
        },
        required: ['topic']
      }
    };
  }

  async execute(args: any) {
    const topic = args.topic;
    const complexity = args.complexity || 'intermediate';
    const timeframe = args.timeframe;

    const query: UserQuery = {
      text: `Research strategy for ${topic}`,
      userLevel: complexity === 'basic' ? 'beginner' : complexity === 'advanced' ? 'expert' : 'intermediate'
    };

    const analysis = await this.guidanceEngine.analyzeQuery(query);
    analysis.intent = 'learning';

    const guidance = await this.guidanceEngine.generateGuidance(query, analysis);

    let formattedResponse = this.formatGuidanceResponse(guidance);

    if (timeframe) {
      formattedResponse += `\n\n### Timeframe Considerations\n`;
      formattedResponse += `Given your ${timeframe} timeframe, prioritize the most critical specifications and focus on practical understanding over exhaustive coverage.\n`;
    }

    return {
      content: [
        {
          type: 'text',
          text: formattedResponse
        }
      ]
    };
  }

  private formatGuidanceResponse(guidance: GuidanceResponse): string {
    let formatted = `# ${guidance.summary}\n\n`;

    guidance.sections.forEach(section => {
      formatted += `## ${section.title}\n\n`;
      formatted += `${section.content}\n\n`;
    });

    if (guidance.nextSteps && guidance.nextSteps.length > 0) {
      formatted += `## Next Steps\n\n`;
      guidance.nextSteps.forEach(step => {
        formatted += `- ${step}\n`;
      });
      formatted += '\n';
    }

    if (guidance.relatedTopics && guidance.relatedTopics.length > 0) {
      formatted += `## Related Topics\n\n`;
      guidance.relatedTopics.forEach(topic => {
        formatted += `- ${topic}\n`;
      });
      formatted += '\n';
    }

    formatted += `---\n*Confidence: ${Math.round(guidance.confidence * 100)}%*\n`;
    formatted += `*Generated by 3GPP MCP Server v2 - Intelligent Guidance*`;

    return formatted;
  }
}